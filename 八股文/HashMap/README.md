### 存储结构

#### HashMap的底层数据结构是什么？

在 JDK1.7 和 JDK1.8 中有所差别：

在 JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。

在 JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：

- 当链表长度超过 8 且数据总量大于等于 64 才会转红黑树。
- 将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。

**JDK1.7 HashMap结构** 

![JDK1.7 HashMap结构](https://gitee.com/xk39/typora-imgs/raw/master/imgs/HashMap-0001.png)



**JDK1.8 HashMap结构** 

![](https://gitee.com/xk39/typora-imgs/raw/master/imgs/HashMap-0002.png)

#### 为什么在解决hash冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树？

因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。

因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。

#### 不用红黑树，用二叉查找树可以吗？

可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。

#### 当链表转为红黑树后，什么时候退化为链表？

为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。

#### 为什么链表改为红黑树的阈值是8？

是因为泊松分布，我们来看作者在源码中的注释：

![](https://gitee.com/xk39/typora-imgs/raw/master/imgs/HashMap-0003.png)

翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。

### 字段结构

#### 默认加载因子是多少？为什么是0.75，不是0.6或者0.8？

回答这个问题前，我们来先看下HashMap的默认构造函数：

![](https://gitee.com/xk39/typora-imgs/raw/master/imgs/HashMap-0004.png)

Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。

默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：

- 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。
- 相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。

我们来追溯下作者在源码中的注释（JDK1.7）：

### 索引计算

#### HashMap中key的存储索引是怎么计算的？

#### JDK1.8为什么要hashcode异或其右移十六位的值？

#### 为什么hash值要与length-1相与？

#### HashMap数组的长度为什么是2的幂次方？

### put方法

#### HashMap的put方法流程？

#### JDK1.7和1.8的put方法是什么？

### 扩容机制

#### HashMap的扩容方式

### JDK1.8的优化

#### 扩容在JDK1.8中有什么不一样？

### 其他

#### 还知道哪些hash算法？

#### key可以作为Null吗？

#### 一般用什么作为HashMap的key？

#### 用可变类当HashMap的key有什么问题？

