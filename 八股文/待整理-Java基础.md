# JVM

## 哪些情况下的对象会被垃圾回收机制处理掉？ 

> 利用可达性分析算法，虚拟机会将一些对象定义为 GC Roots，从 GC Roots 出发沿着引用链向下寻找，如果某个对象不能通过 GC Roots 寻找到，虚拟机就认为该对象可以被回收掉。

## 哪些对象可以被看做是 GC Roots 呢？ 

> 1）虚拟机栈（栈帧中的本地变量表）中引用的对象； 
>
> 2）方法区中的类静态属性引用的对象，常量引用的对象； 
>
> 3）本地方法栈中 JNI(Native 方法）引用的对象；

## 对象不可达，一定会被垃圾收集器回收么？ 

> 即使不可达，对象也不一定会被垃圾收集器回收
>
> 1）先判断对象是否有必要执行 finalize() 方法，对象必须重写 finalize()方法且没有被运行过。
>
> 2）若有必要执行，会把对象放到一个 队列中，JVM 会开一个线程去回收它们，这是对象最后一次可以逃逸清理的机会。

## 如何判断一个对象是否存活？

> 在堆里面存放着 Java 世界中几乎所有的对象实例，垃圾收集器对堆内存进行回收前，都会先判断这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能在被任何途径使用的对象)。一共有两种算法：
>
> 引用计数算法
>
> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时， 计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。 JVM 里面并没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。
>
> 可达性分析算法
>
> 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

## 对象的四种引用

> **强引用**
>
> 只要引用存在，垃圾回收器永远不会回收
>
> ```java
> Object obj = new Object(); 
> User user=new User();
> ```
>
> 可直接通过obj取得对应的对象 如 obj.equels(new Object()); 而这样 obj 对象对后面 new Object 的一个强
> 引用，只有当 obj 这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
>
> **软引用** 
>
> 非必须引用，内存溢出之前进行回收
>
> 可以通过以下代码实现
>
> ```java
> Object obj = new Object();
> SoftReference<Object> sf = new SoftReference<Object>(obj);
> obj = null;
> sf.get();//有时候会返回null
> ```
>
> 这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
>
> **弱引用**
>
> 第二次垃圾回收时回收
>
> 可以通过如下代码实现
>
> ```java
> Object obj = new Object();
> WeakReference<Object> wf = new WeakReference<Object>(obj);
> obj = null;
> wf.get();//有时候会返回null 
> wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
> ```
>
> 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的 isEnQueued 方法返回对象是否被垃圾回收器标记。
> ThreadLocal 中有使用到弱引用，
>
> ```java
> public class ThreadLocal<T> { 
>     static class ThreadLocalMap { 
>         static class Entry extends WeakReference<ThreadLocal<?>> { 
>             /** The value associated with this ThreadLocal. */ 
>             Object value; 
>             Entry(ThreadLocal<?> k, Object v) { 
>                 super(k); 
>                 value = v; 
>             } 
>         } 
>         //.... 
>     }
>     //..... 
> }
> 
> ```
>
> **虚引用**
>
> 垃圾回收时回收，无法通过引用取到对象值
>
> 可以通过如下代码实现
>
> ```java
> Object obj = new Object();
> PhantomReference<Object> pf = new PhantomReference<Object>(obj);
> obj=null;
> pf.get();//永远返回null 
> pf.isEnQueued();//返回是否从内存中已经删除
> ```
>
> 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。

## jvm内存模型，各个部分的特点？

> ![image-20210318061838031](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318061838031.png)
>
> 1. PC寄存器：
>     a. 每个线程拥有⼀个pc寄存器；
>     b. 指向下⼀条指令的地址。
>
> 2. 方法区：
>     a. 保存装载的类的元信息：类型的常量池，字段、方法信息，方法字节码；jdk6时，String等常量信息置于方法区，jdk7移到了堆中；
>     b. 通常和永久区（Perm）关联在⼀起；
>   
>3. 堆：
>     a. 应⽤系统对象都保存在java堆中；
>     b. 所有线程共享java堆；
>     c. 对分代GC来说，堆也是分代的；
> 
>4. 栈：
>     a. 线程私有；
>     b. 栈由⼀系列帧组成（因此java栈也叫做帧栈）；
>     c. 帧保存⼀个方法的局部变量（局部变量表）、操作数栈、常量池指针
>   
>  d. 每⼀次方法调用创建⼀个帧，并压栈。
> 
>
> 
>![image-20210318062017592](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318062017592.png)
> 
>![image-20210318062036080](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318062036080.png)
> 
>

## Java 内存分配？

> 一、 基本概念
>
> 每运行一个 java 程序会产生一个 java 进程，每个 java 进程可能包含一个或者多个线程，每一个 Java 进程对应唯一一个 JVM 实例，每一个 JVM 实例唯一对应一个堆，每一个线程有一个自己私有的栈。进程所创建的所有类的实例（也就是对象）或数组（指的是数组的本身，不是引用）都放在堆中,并由该进程所有的线程共享。Java 中分配堆内存是自动初始化的，即为一个对象分配内存的时候， 会初始化这个对象中变量。虽然 Java 中所有对象的存储空间都是在堆中分配的， 但是这个对象的引用却是在栈中分配,也就是说在建立一个对象时在堆和栈中都分配内存，在堆中分配的内存实际存放这个被创建的对象的本身，而在栈中分配的内存只是存放指向这个堆对象的引用而已。局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待 GC 回收。
>
> 具体的概念：JVM 的内存可分为 3 个区：堆(heap)、栈(stack)和方法区(method， 也叫静态区)；
>
> 堆区： 存储的全部是对象，每个对象都包含一个与之对应的 class 的信息(class 的目的是得到操作指令)； jvm 只有一个堆区(heap)，且被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身和数组本身；
>
> 栈区： 每个线程包含一个栈区，栈中只保存基础数据类型本身和自定义对象的引用；每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问；栈分为 3 个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)；
>
> 方法区（静态区）: 被所有的线程共享，方法区包含所有的 class（class 是指类的原始代码，要创建一个类的对象，首先要把该类的代码加载到方法区中，并且初始化）和 static 变量。 方法区中包含的都是在整个程序中永远唯一的元素，如 class，static 变量。
>
> 二、实例演示 AppMain.java
>
> ![image-20210317043412438](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317043412438.png)
>
> 运行该程序时，首先启动一个 Java 虚拟机进程，这个进程首先从 classpath 中找到 AppMain.class 文件，读取这个文件中的二进制数据，然后把 Appmain 类的类信息存放到运行时数据区的方法区中，这就是AppMain 类的加载过程。
>
> 接着，Java 虚拟机定位到方法区中 AppMain 类的 Main()方法的字节码，开始执行它的指令。 这个 main()方法的第一条语句就是：
>
> ![image-20210317043646695](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317043646695.png)
>
> 该语句的执行过程：
>
> 1、Java 虚拟机到方法区找到 Sample 类的类型信息，没有找到，因为 Sample 类还没有加载到方法区（这里可以看出，java 中的内部类是单独存在的，而且刚开始的时候不会跟随包含类一起被加载，等到要用的时候才被加载）。Java 虚拟机立马加载 Sample 类，把 Sample 类的类型信息存放在方法区里。 
>
> 2、Java 虚拟机首先在堆区中为一个新的 Sample 实例分配内存, 并在 Sample 实例的内存中存放一个方法区中存放 Sample 类的类型信息的内存地址。
>
> 3、JVM 的进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。
>
> 4、位于“=”前的 Test1 是一个在 main()方法中定义的一个变量（一个 Sample 对象的引用），因此，它被会添加到了执行 main()方法的主线程的 JAVA 方法调用栈中。而“=”将把这个 test1 变量指向堆区中的 Sample 实例。
>
> 5、JVM 在堆区里继续创建另一个 Sample 实例，并在 main 方法的方法调用栈中添加一个 Test2 变量，该变量指向堆区中刚才创建的 Sample 新实例。
>
> 6、JVM 依次执行它们的 printName()方法。当 JAVA 虚拟机执行 test1.printName()方法时，JAVA 虚拟机根据局部变量 test1 持有的引用，定位到堆区中的 Sample 实例，再根据 Sample 实例持有的引用，定位到方法去中 Sample 类的类型信息，从而获得 printName()方法的字节码， 接着执行 printName()方法包含的指令，开始执行。


## 在 Java 语言里堆(heap)和栈(stack)里的区别：
>
>栈(stack)与堆(heap)都是 Java 用来在 Ram 中存放数据的地方。与 C++不同，Java 自动管理栈和堆，程序员不能直接地设置栈或堆。
>
>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享（详见下面的介绍）。
>
>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java 的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
>
>Java 中的 2 种数据类型： 
>
>一种是基本类型(primitive types), 共有 8 类，即 int, short, long, byte, float, double, boolean, char(注意，并没有 string 的基本类型)。这种类型的定义是通过诸如 int a = 3; long b = 255L; 的形式来定义的，称为自动变量。自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如 int a = 3; 这里的 a 是一个指向 int 类型的引用，指向 3 这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存于栈中。
>
>栈有一个很重要的特性:**存在栈中的数据可以共享**。
>
>假设我们同时定义: int a = 3; int b = 3; 编译器先处理 int a = 3；首先它会在栈中创建一个变量为 a 的引用，然后查找有没有字面值 为 3 的地址，如果没找到，就开辟一个存放 3 这个字面值的地址，然后将 a 指向 3 的地址。接着处理 int b = 3；在创建完 b 的引用变量后，由于在栈中已经有 3 这个字面值，便将 b 直接指向 3 的地址。这样，就出现了 a 与 b 同时均指向 3 的情况。这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一 个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完 a 与 b 的值后，再令 a=4；那么，b 不会等于 4，还是等于 3。在编译器内部，遇到 a=4；时，它就会重新搜索栈中是否有 4 的字面值，如果没有， 重新开辟地址存放 4 的值；如果已经有了，则直接将 a 指向这个地址。因此 a 值的改变不会影响到 b 的值。
>
>另一种是包装类数据，如 Integer, String, Double 等将相应的基本数据类型包装起来的类。 这些类数据全部存在于堆中，Java 用 new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。

## 如何让栈溢出，如何让方法区溢出？

> 1. 运行时产生大量的类去填满方法区，直到溢出。

## Java 的内存结构，堆分为哪几部分，默认年龄多大进入老年代

> Java 的内存结构：程序计数器、虚拟机栈、本地方法栈、堆、方法区。
>
> Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代。
>
> 默认的设置下，当对象的年龄达到 15 岁的时候，也就是躲过 15 次 Gc 的时候，他就会转移到老年代中去，躲过 15 次 GC 之后进入老年代。

## 哪些对象会被存放到老年代？

> 1. 新⽣代对象每次经历⼀次minor gc，年龄会加1，当达到年龄阈值（默认为15岁）会直接进⼊⽼年代；
> 2. ⼤对象直接进⼊⽼年代；
> 3. 新⽣代复制算法需要⼀个survivor区进⾏轮换备份，如果出现⼤量对象在minor gc后仍然存活的情况时，就需要⽼年代进⾏分配担保，让survivor⽆法容纳的对象直接进⼊⽼年代；
> 4. 如果在Survivor空间中相同年龄所有对象⼤⼩的总和⼤于Survivor空间的⼀半，年龄⼤于或等于该年龄的对象就可以直接进⼊年⽼代。

## Java 堆的结构是什么样子的？

> JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
>
> 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。
>
> 永久代是用于存放静态文件，如 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：类的方法(字节码…)、类名(Sring 对象)、.class 文件读到的常量信息、 class 对象相关的对象列表和类型列表 (e.g., 方法对象的 array)、JVM 创建的内部对象、JIT 编译器优化用的信息
>
> **虚拟机中的共划分为三个代**： 
>
> 年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。 其中持久代主要存放的是 Java 类的类信息，与垃圾收集要收集的 Java 对象关系不大。年轻代和年老代的划分是对垃 圾收集影响比较大的。
>
> 年轻代: 
>
> 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个 Eden 区，两个 Survivor 区(一般而言)。大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象将被复制到 Survivor 区（两个中的一个）， 当这个 Survivor 区满时，此区的存活对象将被复制到另外一个 Survivor 区，当这个 Survivor 去也满了的时候，从第一个 Survivor 区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor 的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 Eden 复制过来对象，和从前一个 Survivor 复制过来的对象，而复制到年老区的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。同时，根据程序需要，Survivor 区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 
>
> 年老代: 
>
> 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
>
> 持久代: 用于存放静态文件，如今 Java 类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。
>
> 注意： JDK1.8中，永久代已经从java堆中移除，String直接存放在堆中，类的元数据存储在meta space 中，meta space 占用外部内存，不占用堆内存。 
>
> 可以说，在 java8 的新版本中，持久代已经更名为了元空间（meta space）。

## java堆的结构，⼀个bean被new出来之后，在内存空间的走向？

> ![image-20210318063121830](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318063121830.png)
>
> 1、JVM中堆空间可以分成三个大区，新生代、老年代、永久代
> 2、新⽣代可以划分为三个区，Eden区，两个Survivor区，在HotSpot虚拟机Eden和Survivor的大小比例为8：1：1

## 简述各个版本内存区域的变化？

> 参考：https://blog.csdn.net/rainnnbow/article/details/50541079

## 说说各个区域的作用？

> 1、运行时数据区域运行时数据区域包括方法区、虚拟机栈、本地方法栈、堆、程序计数器。其中方法区和堆是所有线程共享的数据区，其他的是线程隔离的数据区。
>
> 程序计数器：
>
> 程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，确定下一条需要执行的字节码指令。java 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何确定的一个时刻，一个处理器只会执行一条线程中的指令。为了线程切换之后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响。如果线程正在执行的是一个java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是 native 方法，则计数器值 为空。
>
> java 虚拟机栈
>
> java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存在局部变量表、操作栈、动态链接、方法出口等信息。通常所说的栈是局部变量表，即与对象内存分配关系最密切的内存区域。局部变量表的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是确定的，在运行期不会改变。java 虚拟机栈有两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，则抛弃 StackOverflowError 异常；如果虚拟机栈是可以动态扩展的，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。
>
> 本地方法栈
>
> 本地方法栈与虚拟机栈所发挥的作用是相似的，区别在于虚拟机栈为虚拟机执行 java 方法的服务，本地方法栈则是为虚拟机使用到 native 方法服务。
>
> java 堆
>
> java 堆是虚拟机所管理的内存中最大的一块，是虚拟机创建的能被所有线程共享的一块内存区域。java 堆的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存（随着 JTI 编译器的发展，在栈上也有可能分配）。java 堆是垃圾收集器管理的主要区域，在物理上可以是不连续的内存空间，但在逻辑上是连续的。如果在堆中没有内存完成实例的分配，并且堆也无法在扩展的时候，将会抛出 OutOfMemoryError 异常。
>
> 方法区
>
> 方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、 即时编译器编译后的代码等数据。这块区域很少进行垃圾回收，甚至可以不实现垃圾收集，主要是针对常量池的回收和对类型的卸载。当方法区无法分配内存的时候，将抛出 OutOfMemoryError 异常。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期的各种字面量和符号引用。并非预置入 Class 文件中的常量才能进入常量池，运行期间也可能将新的常量放入池中，开发中用的比较多的是 String 类的 intern()方法。
>
> 例子解析
>
> ![image-20210317060140114](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317060140114.png)
>
> 假设这句代码出现在方法体中，那么 Object obj 将会反映到 java 栈的局部变量表中，作为一个 reference 类型数据出现，new Object()将会反映到 java 堆中，形成一块存储了 Object 类型的实例数据的结构化内存，此对象类型数据，如对象类型、父类、实现的接口、方法 等信息存储在方法区。

## jdk1.7 到 jdk1.8 java 虚拟机发生了什么变化? 

> JVM 中内存份为堆、栈内存，及方法区。 
>
> 栈内存主要用途：执行线程方法，存放本地临时变量与线程方法执行是需要的引用对象的地址。 
>
> 堆内存主要用途：JVM 中所有对象信息都存放在堆内存中，相比栈内存，堆内存大很多,所以 JVM 一直通过对堆内存划分不同功能区块实现对堆内存中对象管理。 
>
> 堆内存不够常见错误：OutOfMemoryError 
>
> 栈内存溢出常见错误：StackOverFlowError 
>
> 在 JDK7 以及其前期的 JDK 版本中，堆内存通常被分为三块区域 Nursery 内存(young generation)、长时内存(old generation)、永久内存(Permanent Generation for VM Matedata)， 显示如下图：
>
> ![image-20210316082343866](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316082343866.png)
>
> 在最上面一层是 Nursery 内存，一个对象被创建以后首先被放到 Nuersery 中的 Eden 内存中，如果存活周期超过两个 Survivor（生存周期）之后会被转移到 Old Generation 中。 
>
> 永久内存中存放对象的方法、变量等元数据信息。永久内存不够就会出现以下错误： java.lang.OutOfMemoryError:PermGen 
>
> 但是在 JDK1.8 中一般都不会得到这个错误，原因在于1.8 中把存放元数据的永久内存从堆内存中已到了本地内存（native Memory）中，1.8 中 JVM 内存结构变成了如下图：
>
> ![image-20210316082554752](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316082554752.png)
>
> 这样永久内存就不占用堆内存，可以通过自增长来避免永久内存错误。 
>
> -XX:MaxMetaspaceSize=128m 这只最大的远内存空间 128 兆 
>
> JDK1.8 移除 PermGen，取而代之的是 MetaSpace 源空间 
>
> MetaSpace 垃圾回收：对僵死的类及类加载器的垃圾回收机制昂在元数据使用达到 “MaxMetaSpaceSize”参数的设定值时运行。 
>
> MetaSpace 监控：元空间的使用情况可以在 HotSpot1.8 的详细 GC 日志输出中得到。 
>
> 更新 JDK1.8 的原因：
>
> 1.字符串存在永久代当中，容易出现性能问题和内存溢出 
>
> 2.类及方法的信息比较难确定其大小，因此对永久代的大小制定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 
>
> 3.永久代会为 GC 带来不必要的复杂度，并且回收效率偏低 
>
> 4.Oracle 可能会想 HotSpot 与 JRockit 合并。

## 描述一下 JVM 加载 Class 文件的原理机制?

> **动态加载** **三个类加载器** **委托模型机制**  **装载 链接 初始化** 

> 在面试 java 工程师的时候，这道题经常被问到，故需特别注意。 Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。 Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。 Java 的类加载器有三个，对应 Java 的三种类:
>
> ![image-20210317035520829](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317035520829.png)
>
> 三个加载器各自完成自己的工作，但它们是如何协调工作呢？哪一个类该由哪个类加载器完成呢？为了解决这个问题，Java 采用了委托模型机制。
>
> 委托模型机制的工作原理很简单：当类加载器需要加载类的时候，先请示其 Parent(即上一 层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到 jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。 我们可以通过这样的代码来获取类加载器:
>
> ![image-20210317035707498](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317035707498.png)
>
> 注意一个很重要的问题，就是 Java 在逻辑上并不存在 BootstrapKLoader 的实体！因为它是用 C++编写的，所以打印其内容将会得到 null。 
>
> 前面是对类加载器的简单介绍，它的原理机制非常简单，就是下面几个步骤: 
>
> 1.装载:查找和导入 class 文件;
>
> 2.连接:
>
> ![image-20210317035821752](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317035821752.png)
>
> 3.初始化:初始化静态变量，静态代码块。
>
> ![image-20210317035857040](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317035857040.png)
>
> 来源：https://www.cnblogs.com/wenjiang/archive/2013/04/26/3044132.html

## Java 类加载过程？

> 在 Java 中，类装载器把一个类装入 Java 虚拟机中，要经过三个步骤来完成：装载、链接和初始化，其中链接又可以分成校验、准备、解析
>
> 装载：查找和导入类或接口的二进制数据；
>
> 链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；
>
> 校验：检查导入类或接口的二进制数据的正确性；
>
> 准备：给类的静态变量分配并初始化存储空间；
>
> 解析：将符号引用转成直接引用；
>
> 初始化：激活类的静态变量,初始化 Java 代码和静态 Java 代码块

## 类加载机制

> 1. 概念：虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）。
> 2. 类⽣命周期：
> 类加载过程：读取⼆进制字节流到jvm—>验证格式语义等—>为静态变量分配内存空间—>常量池引⽤解析—>执行static标识的代码
> a. 加载过程：通过⼀个类的全限定名来获取定义此类的⼆进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成⼀个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
> b. 验证过程：为了确保Class⽂件的字节流中包含的信息符合当前虚拟机的要求，⽂件格式验证、元数据验证、字节码验证、符号引用验证；
> c. 准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在⽅法区中进行分配；准备阶段，static对象会被设置默认值，static final对象会被赋上给予的值。
> d. 解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程。
> i. 符号引⽤：字符串，引用对象不⼀定被加载；
> ii. 直接引⽤：指针或者地址偏移量，引用对象⼀定在内存中。
> e. 初始化阶段：类初始化阶段是类加载过程的最后⼀步。初始化阶段就是执行类构造器<clint>()方法的过程。
> f. 使用阶段：
> g.卸载阶段：

## 类加载器，双亲委派模型？

> 1. BootStrap ClassLoader 启动ClassLoader
> 2. Extension ClassLoader 扩展ClassLoader
> 3. App ClassLoader 应用ClassLoader/系统ClassLoader
> 4. Custom ClassLoader 自定义ClassLoader
>
> > 除了BootStrap ClassLoader，每个ClassLoader都有⼀个Parent作为⽗亲。
> > 1. 自底向上检查类是否已经加载；
> > 2. 自顶向下尝试加载类。
>
> 双亲委派机制：
>
> 当⼀个类收到了类加载请求，他⾸先不会尝试自己去加载这个类，⽽是把这个请求委派给父类去完成，每一
> 个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈⾃⼰⽆法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
>
> ![image-20210318062509548](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318062509548.png)

## 什么是类加载器？

> 类加载器是一个用来加载类文件的类。Java 源代码通过 javac 编译器编译成类文件。然后 JVM 来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。

## 类加载器有哪些？

> 有三种默认使用的类加载器：Bootstrap 类加载器、Extension 类加载器和 Application 类加载器。每种类加载器都有设定好从哪里加载类。
>
> Bootstrap 类加载器负责加载 rt.jar 中的 JDK 类文件，它是所有类加载器的父加载器 。 Bootstrap 类加载器没有任何父类加载器，如果你调用 String.class.getClassLoader() ，会返回 null ，任何基于此的代码会抛出NullPointerException 异常。Bootstrap 加载器被称为初始类加载器。 
>
> 而 Extension 将加载类的请求先委托给它的父加载器，也就是 Bootstrap，如果没有成功加载的话，再从 jre/lib/ext 目录下或者 java.ext.dirs 系统属性定义的目录下加载类。Extension 加载器由 sun.misc.Launcher$ExtClassLoader 实现。
>
> 第三种默认的加载器就是 Application 类加载器了。它负责从 classpath 环境变量中加载某些应用相关的类，classpath 环境变量通常由-classpath 或-cp 命令行选项来定义，或者是 JAR 中的 Manifest 的 classpath 属性。Application 类加载器是 Extension 类加载器的子加载器。通过 sun.misc.Launcher$AppClassLoader 实现。

## 类加载器双亲委派模型机制？ 

> 什么是双亲委派模型(Parent-Delegation Model)？为什么使用双亲委派模型？
>
> JVM 中加载类机制采用的是双亲委派模型，顾名思义，在该模型中，子类加载器收到的加载请求，不会先去处理，而是先把请求委派给父类加载器处理，当父类加载器处理不了时再返回给子类加载器加载；
>
> 为什么使用双亲委派模型？
>
> 因为安全。使用双亲委派模型来组织类加载器间的关系，能够使类的加载也具有层次关系，这样能够保证核心基础的 Java 类会被根加载器加载，而不会去加载用户自定义的和基础类库相同名字的类，从而保证系统的有序、安全。

## 什么是 tomcat 类加载机制？

> 在 tomcat 中类的加载稍有不同，如下图：
>
> ![image-20210317041249182](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317041249182.png)
>
> 当 tomcat 启动时，会创建几种类加载器：
>
> 1.Bootstrap 引导类加载器：加载 JVM 启动所需的类，以及标准扩展类（位于 jre/lib/ext 下）
>
> 2.System 系统类加载器：加载 tomcat 启动的类，比如 bootstrap.jar ，通常在 catalina.bat 或者catalina.sh 中指定。位于 CATALINA_HOME/bin 下。
>
> ![image-20210317041924223](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317041924223.png)
>
> 3.Common 通用类加载器
>
> 加载 tomcat 使用以及应用通用的一些类，位于 CATALINA_HOME/lib 下，比如 servlet-api.jar
>
> ![image-20210317042105682](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317042105682.png)
>
> 4.webapp 应用类加载器
>
> 每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF/lib 下的 jar 文件中的 class 和 WEB-INF/classes 下的 class 文件。
>
> 当应用需要到某个类时，则会按照下面的顺序进行类加载：
>
> 1)使用 bootstrap 引导类加载器加载
>
> 2)使用 system 系统类加载器加载
>
> 3)使用应用类加载器在 WEB-INF/classes 中加载
>
> 4)使用应用类加载器在 WEB-INF/lib 中加载
>
> 5)使用 common 类加载器在 CATALINA_HOME/lib 中加载
>
> > 参考：https://blog.csdn.net/dreamcatcher1314/article/details/78271251

## 什么是 GC? 为什么要有 GC？

> GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方， 忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc()或 Runtime.getRuntime().gc()，但 JVM 可以屏蔽掉显式的垃圾回收调用。
>
> 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。
>
> 在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。
>
> 采用“分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
>
> Eden区：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
>
> Survivor区：从Eden幸存下来的对象会被挪到这里。 
>
> Tenured区：这是足够老的对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进Tenured时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
>
> 与垃圾回收相关的 JVM 参数：
>
> -Xms / -Xmx  堆的初始大小 / 堆的最大大小 
>
> -Xmn   堆中年轻代的大小
>
> 补充： Java 是由 C++发展来的。 它摈弃了 C++中一些繁琐容易出错的东西。其中有一条就是这个GC。写 C/C++程序，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。内存再大也是有限的，所以当程序不再需要使用某个变量的时候，就需要释放这个内存空间资源， 好让别的变量来用它。在 C/C++中，释放无用变量内存空间的事情要由程序员自己来解决。 就是说当程序员认为变量没用了，就应当写一条代码，释放它占用的内存。这样才能最大程度地避免内存泄露和资源浪费。但是这样显然是非常繁琐的。程序比较大，变量多的时候往往程序员就忘记释放内存或者在不该释放的时候释放内存了。而且释放内存这种事情，从开发角度说，不应当是程序员所应当关注的。程序员所要做的应该是实现所需要的程序功能，而不是耗费大量精力在内存的分配释放上。Java 有了 GC，就不需要程序员去人工释放内存空间。当 Java 虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在 Java 程序中显式地使用 System.gc()来强制进行一次立即的内存清理。 因为显式声明是做堆内存全扫描，也就是 Full GC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？而其**显式调用 System.gc()只是给虚拟机一个建议，不一定会执行，因为System.gc()在一个优先级很低的线程中执行。**

## GC特点

> JVM 回收特点：(stop-the-world)当要进行垃圾回收时候，不管何种 GC 算法，除了垃圾回收的线程之外其他任何线程都将停止运行。被中断的任务将会在垃圾回收完成后恢复进行。 GC 不同算法或是 GC 调优就是减少 stop-the-world 的时间。
>
> 为何非要 stop-the-world
>
> 就像是一个同学的聚会，地上有很多垃圾，你去打扫，边打扫边丢垃圾怎么都不可能打扫干净的哈。当在垃圾回收时候不暂停所有的程序，在垃圾回收时候有 new 一个新的对象 B，此时对象 A 是可达 B 的，但是没有来及标记就把 B 当成无用的对象给清理掉了，这就会导致程序的运行会出现错误。

## 什么时候触发full gc？

> （1）调⽤System.gc时，系统建议执⾏Full GC，但是不必然执⾏
> （2）⽼年代空间不足
> （3）⽅法区空间不足
> （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
> （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可⽤内存，则把该对象转存到老年代，且老年代的可⽤内存小于该对象大小

## 垃圾回收的优点和原理，并考虑 2 种回收机制？基本原理是什么？

> Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或 者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃 圾回收。
>
> 回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

## 如何判断哪些对象需要回收呢

> **引用计数算法（java 中不是使用此方法）**
>
> 每个对象中添加一个引用计数器，当有别人引用它的时候，计数器就会加 1，当别人不引用它的时候，计数器就会减 1，当计数器为 0 的时候对象就可以当成垃圾。算法简单，但是最大问题就是在循环引用的时候不能够正确把对象当成垃圾。
>
> **根搜索方法（这是后面垃圾搜集算法的基础）：**
>
> 这是 JVM 一般使用的算法，设立若干根对象，当上述若干个跟对象对某一个对象都不可达的时候，这个对象就是无用的对象。对象所占的内存可以回收。 根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记- 清除算法、复制算法、标记-整理算法。
>
> **标记-消除算法：**
>
> 当堆中的有效内存被耗尽的时候，就会停止整个系统，就会调用标记- 消除算法，主要做两件事，1就是标记，2就是清除。然后让程序恢复。
>
> 标记：遍历所有 GCroots 把可达的对象标记为存活的对象。
>
> 清除：把未标记为存活的对象清楚掉。
>
> 缺点： 就是效率相对比较低。会导致 stop-the-world 时间过长。因为无用的对象内存不是连续的因此清理后的内存也不是连续的，(会产生内存碎片)因此 JVM 还要维持一个空闲列表，增加一笔开销，同时在以后内存使用时候，去查找可用的内存 这个效率也是很低的。
>
> **复制算法：(这个算法一般适合在新生代 GC)**
>
> 将原有的内存分为两块，每次只使用其中的一块，在垃圾回收的时候，将一块正在使用的内存中存活(上述根搜索的算法)的对象复制到另一块没有使用的内存中，原来的那一块全部清除。与上述的标记-清除算法相比效率更高，但是不太适合使用在对象存活较多的情况下(如老年代)。
>
> **缺点：**每次对整个半区内存回收，因此效率比上面的要高点，同时在分配内存的时候不需要考虑内存的碎片。按照顺序分配内存。简单高效。但是最大的问题在于此算法在对象存活率非常低的时候使用，将可用内存分为两份，每次只使用一份这样极大浪费了内存。
>
> **注意（重要）**：现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一 块为 Eden 和两块较小的 Survivor 空间(**比例->8:1:1**)。每次使用 Eden 和其中的一块 Survivor， 垃圾回收时候将上述两块中存活的对象复制到另外一块 Survivor 上，同时清理上述 Eden 和 Survivor。所以每次新生代就可以使用 90%的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor 不够时候，需要老年代来分担，大对象直接进入老年代) 
>
> **标记-整理算法：(老年代 GC)**
>
> 在存活率较高的情况下，复制的算法效率相对比较低，同时还要考虑存活率可能为 100%的极端情况，因此又不能把内存分为两部分的复制算法。 在上面标记-复制算法的基础之上，演变出了一个新的算法就是标记-整理算法。首先从 GCroots 开始标记所有可达的对象，标记为存活的对象。然后将存活的对象压缩到内存一端 按照内存地址的次序依次排列，然后末端内存地址之后的所有内存都清除。 
>
> **总结：**将标记存活的对象按照内存地址顺序排列到内存另一端，末端内存地址之后的内存都会被清除。
>
> **比较：**相比较于标记-清楚算法(传统的)，该算法可以解决内存碎片问题同时还可以解决复制算法部分内存不能利用的问题。但是标记-整理算法的效率也不是很高。
>
> 上述算法都是根据根节点搜索算法来判断一个对象是不是需要回收，而支撑根节点搜索算法能够正常工作理论依据就是语法中变量作用域的相关内容。
>
> 三种算法比较： 
>
> **效率：**复制算法>标记-整理算法>标记-清除算法；
>
> **内存整齐度：**复制算法=标记-整理算法>标记-清除算法
>
> **内存利用率：**标记-整理算法=标记-清除算法>复制算法
>
> 分代收集算法：
> 现在使用的 Java 虚拟机并不是只是使用一种内存回收机制，而是分代收集的算法。就是将内存根据对象存活的周期划分为几块。一般是把堆分为新生代和老年代。短命对象存放在新生代中，长命对象放在老年代中。对于不同的代，采用不同的收集算法。
>
>  **新生代：**由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。
>
> **老年代：**由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法
>
> **注意**：新生态由于根据统计可能有 98%对象存活时间很短因此将内存分为一块比较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。

## cms垃圾回收机制

> 1、概念：CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，
> 2、使用场景：GC过程短暂停，适合对时延要求较高的服务，用户线程不允许长时间的停顿。
> 3、缺点：
>
> ​	1、服务长时间运行，造成严重的内存碎片化。
> ​	2、算法实现比较复杂（如果也算缺点的话）。
> 4、实现机制：根据GC的触发机制分为：
> ​	1、周期性Old GC（被动）：2s执行一次；
> ​	2、主动Old GC：触发条件：
> ​		i. YGC过程发生Promotion Failed，进而对老年代进行回收
> ​		ii. 比如执行了System.gc()，前提是没有参数ExplicitGCInvokesConcurrent
> ​		iii. 其它情况...

## 垃圾回收的具体实现，常见的五个垃圾回收器

> 一：串行收集器：（Serial 收集器）
>
> 该收集器最古老、稳定简单是一个单线程的收集器，（stop-the-world）可能会产生长时间的停顿。Serial 收集器一定不能用于服务器端。这个收集器类型仅应用于单核 CPU 桌面电脑。新生代和老年代都会使用 Serial 收集器。新生代使用复制算法（内存分三块的那个复制算法）。老年代使用标记-整理算法。
>
> 二：并行收集器：（Parallel 收集器）
>
> parallel 收集器使用多线程并行处理 GC，因此更快。当有足够大的内存和大量芯数时，parallel 收集器是有用的。它也被称为“吞吐量优先垃圾收集器。” 
>
> 三：并行收集器：（Parallel Old 垃圾收集器）
>
> 相比于 parallel 收集器，他们的唯一区别就是在老年代所执行的 GC 算法的不同。它执行三个步骤：标记-汇总-压缩（mark – summary – compaction）。汇总步骤与清理的不同之处在于，其将依然幸存的对象分发到 GC 预先处理好的不同区域，算法相对清理来说略微复杂一点。
>
> 四：并行收集器：（CMS 收集器）
>
> （ConcurrentMark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。 适合应用在互联网站或者 B/S 系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。
>
> 五：G1 收集器
>
> 这个类型的垃圾收集算法是为了替代 CMS 收集器而被创建的，因为 CMS 收集器在长时间持续运行时会产生很多问题。

## jvm中哪些地方会出现oom？分别说说oom的可能原因？

> jvm发⽣oom的四种情况：https://blog.csdn.net/QQ578473688/article/details/77752080

## 我们如何发现oom来自jvm中哪个区域？

## 讲一下 oom 以及遇到这种情况怎么处理的，是否使用过日志分析工具

> OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，当 JVM 因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个 error。
>
> 处理过程：
>
> 首先通过内存映射分析工具，如 Eclipse Memory Analyzer 堆 dump 出的异常堆转储进行快照解析确认内存中的对象是否是必要的， 也就是先分清楚是内存泄漏 Memory Leak 还是 Memory Overflow
>
> 如果是内存泄漏可通过工具进一步查看泄露的对象到 GC Roots 的引用链，就能找到泄露对象是怎么通过路径与 GC Roots 相关联导致垃圾收集器无法回收他们。
>
> 如果不存在泄露，就检查堆参数 -Xmx 与 -Xms 与机器物理内存对比是否还可以调大，从代码上检测是否是某些对象的生命周期过长持有状态时间过长，尝试减少代码运行期间的内存消耗。 
>
> 参考文章：https://www.cnblogs.com/ThinkVenus/p/6805495.html

## 有没有jvm调优经验？调优方案有哪些？

> 1. 调优时机：
> a. heap 内存（老年代）持续上涨达到设置的最大内存值；
> b. Full GC 次数频繁；
> c. GC 停顿时间过长（超过1秒）；
> d. 应用出现OutOfMemory 等内存异常；
> e. 应用中有使用本地缓存且占用大量内存空间；
> f. 系统吞吐量与响应性能不高或下降。
> 2. 调优原则：
> a. 多数的Java应用不需要在服务器上进行JVM优化；
> b. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
> c. 在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
> d. 减少创建对象的数量；
> e. 减少使用全局变量和大对象；
> f. JVM优化是到最后不得已才采用的⼿段；
> g. 在实际使用中，分析GC情况优化代码比优化JVM参数更好；
> 3. 调优目标：
> a. GC低停顿；
> b. GC低频率；
> c. 低内存占⽤；
> d. 高吞吐量；
> 4. 调优步骤：
> a. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；
> b. 确定jvm调优量化目标；
> c. 确定jvm调优参数（根据历史jvm参数来调整）；
> d. 调优一台服务器，对比观察调优前后的差异；
> e. 不断的分析和调整，知道找到合适的jvm参数配置；
> f. 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。

## 写出几个jvm优化配置参数。

> 1. 设定堆内存大小，这是最基本的。
> 2. -Xms：启动JVM时的堆内存空间。
> 3. -Xmx：堆内存最大限制。
> 4. 设定新⽣代大小。
> 5. 新⽣代不宜太小，否则会有大量对象涌入老年代。
> 6. -XX:NewRatio：新生代和老年代的占比。
> 7. -XX:NewSize：新生代空间。
> 8. -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比。
> 9. -XX:MaxTenuringThreshold：对象进⼊老年代的年龄阈值。
> 10. 设定垃圾回收器
> 年轻代：-XX:+UseParNewGC。
> 老年代：-XX:+UseConcMarkSweepGC。
> CMS可以将STW时间降到最低，但是不对内存进行压缩，有可能出现“并行模式失败”。比如老年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要比Parallel GC长很多。
> G1采用”标记-整理“算法，解决了内存碎⽚问题，建立了可预测的停顿时间类型，能让使用者指定在⼀个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

# Java常见类

## 说说java集合，每个集合下⾯有哪些实现类，及其数据结构？

> 深⼊理解这篇：https://www.jianshu.com/p/63e76826e852

## Hashcode（）和 equals（）和==区别? 

> (1) hashcode()方法跟 equals()在 java 中都是判断两个对象是否相等 
>
> (2) 两个对象相同，则 hashcode 至一定要相同，即对象相同 ---->成员变量相同 ---->hashcode 值一定相同 
>
> (3) 两个对象的 hashcode 值相同，对象不一定相等。总结：equals 相等则 hashcode 一定相等，hashcode 相等，equals 不一定相等。 
>
> (4) ==比较的是两个引用在内存中指向的是不是同一对象（即同一内存空间）

## java 中= =和equal和hashCode的区别

1）= =若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。对象是存放在堆中，栈中存放的对象的引用，所以= =是对栈中的值进行比较，若返回 true 代表变量的内存地址相等；

2）equals 是 Object 类中的方法，Object 类的 equals 方法用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。若是类中覆盖了 equals 方法，就要根据具体代码来确定，一般覆盖后都是通过对象的内容是否相等来判断对象是否相等。

3）hashCode()计算出对象实例的哈希码，在对象进行散列时作为 key 存入。之所以有 hashCode 方法，因为在批量的对象比较中，hashCode 比较要比 equals 快。在添加新元素时，先调用这个元素的 hashCode 方法，一下子能定位到它应该旋转的物理位置，若该位置没有元素，可直接存储；若该位置有元素，就调用它的 equals 方法与新元素进行比较， 若相同则不存，不相同，就放到该位置的链表末端。 

4）equals 与 hashCode 方法关系：

hashCode()是一个本地方法，实现是根据本地机器上相关的。equals()相等的对象， hashCode()也一定相等；hashCode()不等，equals()一定也不等；hashCode()相等，equals() 可能相等，也可能不等。

**所以在重写equals(Object obj) 方法，有必要重写 hashCode() 方法 ，确保通过equals(Object obj)方法判断结果为 true 的两个对象具备相等的 hashCode()返回值。** 

5）equals 与= =的关系：

Integer b1 = 127;在 java 编译时被编译成 Integer b1 = Integer.valueOf(127);对于-128 到 127 之间的 Integer 值，用的是原生数据类型 int，会在内存里供重用，也就是这之间的 Integer 值进行= =比较时，只是进行 int 原生数据类型的数值进行比较。而超出-128〜127 的范围，进行= =比较时是进行地址及数值比较。

## Java 中 String 的了解

> 1）String 类是 final 型，固 String 类不能被继承，它的成员方法也都默认为 final 方法。String 对象一旦创建就固定不变了，对 String 对象的任何改变都不影响到原对象，相关的任何改变操作都会生成新的 String 对象。 
>
> 2）String 类是通过 char 数组来保存字符串的，String 对 equals 方法进行了重定，比较的是值相等。
>
> ```java
> String a = "test"; 
> String b = "test"; 
> String c = new String("test"); 
> ```
>
> a、b 和字面上的 test 都是指向 JVM 字符串常量池中的"test"对象，他们指向同一个对象。而 new 关键字一定会产生一个对象 test，该对象存储在堆中。所以 new String("test")产生了两个对象，保存在栈中的 c 和保存在堆中的 test。而在 java 中根本就不存在两个完全一模一样的字符串对象，故在堆中的 test 应该是引用字符串常量池中的 test。 例：
>
> ```java
> String str1 = "abc"; //栈中开辟一块空间存放引用 str1，str1 指向池中 String 常量"abc" 
> String str2 = "def"; //栈中开辟一块空间存放引用 str2，str2 指向池中 String 常量"def" 
> String str3 = str1 + str2;//栈中开辟一块空间存放引用 str3 //str1+str2 通过 StringBuilder 的最后一步 toString()方法返回一个新的 String 对象"abcdef" //会在堆中开辟一块空间存放此对象，引用str3指向堆中的(str1+str2)所返回的新String对象。 
> System.out.println(str3 == "abcdef");//返回 false 
> ```
>
> 因为 str3 指向堆中的"abcdef"对象，而"abcdef"是字符池中的对象，所以结果为 false。JVM 对 String str="abc"对象放在常量池是在编译时做的，而 String str3=str1+str2 是在运行时才知 道的，new 对象也是在运行时才做的。

## String 为什么要设计成不可变的？ 

> 1）字符串常量池需要 String 不可变。因为 String 设计成不可变，当创建一个 String 对象时， 若此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象。 如果字符串变量允许必变，会导致各种逻辑错误，如改变一个对象会影响到另一个独立对象。
>
> 2）String 对象可以缓存 hashCode。字符串的不可变性保证了 hash 码的唯一性，因此可以缓存 String 的 hashCode，这样不用每次去重新计算哈希码。在进行字符串比较时，可以直接比较 hashCode，提高了比较性能； 
>
> 3）安全性。String 被许多 java 类用来当作参数，如 url 地址，文件 path 路径，反射机制所需的 Strign 参数等，若 String 可变，将会引起各种安全隐患。

## String、StringBuffer、StringBuilder 区别

> 都是字符串类，String 类中使用字符数组保存字符串，因有 final 修饰符，String 对象是不可变的，每次对String 操作都会生成新的 String 对象，这样效率低，且浪费内存空间。但线程安全。
>
> StringBuilder 和 StringBuffer 也是使用字符数组保存字符，但这两种对象都是可变的，即对字符串进行append 操作，不会产生新的对象。
>
> 它们的区别是：**StringBuffer 对方法加了同步锁是线程安全的，StringBuilder 非线程安全。**

## String 转换成 Integer 的方式及原理

> 1）parseInt(String s)内部调用 parseInt(s, 10)默认为 10 进制。
>
> 2）正常判断 null\进制范围，length 等。
>
> 3）判断第一个字符是否是符号位。
>
> 4）循环遍历确定每个字符的十进制值。
>
> 5）通过*=和-=进行计算拼接。
>
> 6）判断是否为负值返回结果。

## int 与 integer 的区别

> Integer 是 int 的包装类，int 则是 java 的一种基本数据类型，Integer 变量必须实例化才能使用，当 new 一个 Integer 时，实际是生成一个指向此对象的引用，而 int 是直接存储数据的值，Integer 默认值是 null，而 int 默认值是 0

## List 和 Set 的区别

> List , Set 都是继承自 Collection 接口 
>
> List 特点：元素有放入顺序，元素可重复
>
> Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是由该元素的 HashCode 决定的，其位置其实是固定的，加入Set 的 Object 必须定义 equals ()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）
>
> Set和List对比 
>
> Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
> List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。

## HashSet 是如何保证不重复的？

> 向 HashSet 中 add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合 equles 方法比较。 HashSet 中的 add ()方法会使用 HashMap 的 add ()方法。以下是 HashSet 部分源码： 
>
> ```java
> private static final Object PRESENT = new Object(); 
> private transient HashMap<E,Object> map; 
> public HashSet() { 
>     map = new HashMap<>(); 
> }
> public boolean add(E e) { 
>     return map.put(e, PRESENT)==null; 
> }
> ```
>
> HashMap 的 key 是唯一的，由上面的代码可以看出 HashSet 添加进去的值就是作为 HashMap 的key。所以不会重复（ HashMap 比较key是否相等是先比较 hashcode 在比较 equals ）。

## HashMap 如何解决 Hash 冲突

> 通过引入单向链表来解决 Hash 冲突。当出现 Hash 冲突时，比较新老 key 值是否相等， 如果相等，新值覆盖旧值。如果不相等，新值会存入新的 Node 结点，指向老节点，形成链式结构，即链表。 当 Hash 冲突发生频繁的时候，会导致链表长度过长，以致检索效率低，所以 JDK1.8 之 后引入了红黑树，当链表长度大于 8 时，链表会转换成红黑书，以此提高查询性能。 
>
> 参考文章：https://blog.csdn.net/qedgbmwyz/article/details/79908333

## HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?

> 不是线程安全的；
> 如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位置还没有其他的数据。所以这两个线程都会进入我在上面标记为1的代码中。假设一种情况，线程A通过if判断，该位置没有哈希冲突，进入了if语句，还没有进行数据插入，这时候 CPU 就把资源让给了线程B，线程A停在了if语句里面，线程B判断该位置没有哈希冲突（线程A的数据还没插入），也进入了if语句，线程B执行完后，轮到线程A执行，现在线程A直接在该位置插入而不用再判断。这时候，你会发现线程A把线程B插入的数据给覆盖了。发生了线程不安全情况。本来在 HashMap 中，发生哈希冲突是可以用链表法或者红黑树来解决的，但是在多线程中，可能就直接给覆盖了。
> 上面所说的是一个图来解释可能更加直观。如下面所示，两个线程在同一个位置添加数据，后面添加的数据就覆盖住了前面添加的。
>
> ![image-20210315110038909](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210315110038909.png)
>
> 如果上述插入是插入到链表上，如两个线程都在遍历到最后一个节点，都要在最后添加一个数据，那么后面添加数据的线程就会把前面添加的数据给覆盖住。则
>
> ![image-20210315110317218](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210315110317218.png)
>
> 在扩容的时候也可能会导致数据不一致，因为扩容是从一个数组拷贝到另外一个数组。

## HashMap 的扩容过程

> 当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。
> 扩容( resize )就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。
>
> ```java
> HashMap hashMap=new HashMap(cap);
> ```
>
> cap =3， hashMap 的容量为4；
>
> cap =4， hashMap 的容量为4；
>
> HashMap hashMap=new HashMap(cap);
> cap =5， hashMap 的容量为8；
>
> cap =9， hashMap 的容量为16；
> 如果 cap 是2的n次方，则容量为 cap ，否则为大于 cap 的第一个2的n次方的数。

## jdk1.7 到 jdk1.8 Map 发生了什么变化(底层)? 

> 1.8 之后 hashMap 的数据结构发生了变化，从之前的单纯的数组+链表结构变成数组+链 表+红黑树。也就是说在 JVM 存储 hashMap 的 K-V 时仅仅通过 key 来决定每一个 entry 的存 储槽位（Node[]中的 index）。并且 Value 以链表的形式挂在到对应槽位上（1.8 以后如果 value 长度大于 8 则转为红黑树）。 但是 hashmap1.7 跟 1.8 中都没有任何同步操作，容易出现并发问题，甚至出现死循环 导致系统不可用。解决方案是 jdk 的 ConcurrentHashMap，位于 java.util.concurrent 下，专门 解决并发问题。

## 说说HashMap、ConcurrentHashMap数据结构，1.7与1.8的区别？

> 1、数据结构：
> 以下是ConcurrentHashMap的类图：
>
> ![image-20210318063946845](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318063946845.png)
>
> ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是⼀种可重入锁ReentrantLock，在ConcurrentHashMap中扮演锁的角色，HashEntry则用于存储键值对数据。⼀个ConcurrentHashMap中包含⼀个Segment数组，Segment的结构和HashMap类似，是⼀种数组和链表结构。⼀个Segment⾥⾯包含⼀个HashEntry数组，每个HashEntry是⼀个链表的元素。每个Segment拥有⼀个锁，当对HashEntry数组的数据进行修改时，必须先获得对应的Segment锁，如图所示：
>
> ![image-20210318064113922](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210318064113922.png)
>
> 2、concurrenthashmap 1.7和1.8区分：
> 去除 Segment + HashEntry + Unsafe的实现，改为 Synchronized + CAS + Node + Unsafe的实现
> 其实 Node 和 HashEntry 的内容⼀样，但是HashEntry是⼀个内部类。用 Synchronized + CAS 代替 Segment ，这样锁的粒度更⼩了，并且不是每次都要加锁了，CAS尝试失败了再加锁。
> put()方法中初始化数组大小时，1.8不用加锁，因为用了个 sizeCtl变量，将这个变量置为-1，就表明table正在初始化。

## 谈谈数据结构，比如TreeMap。

> 详见：https://my.oschina.net/u/566591/blog/1548176

## ConcurrentHashMap 如何保证线程安全，jdk1.8 有什么变化

> JDK1.7：使用了分段锁机制实现 ConcurrentHashMap，ConcurrentHashMap 在对象中保存了一个 Segment 数组，即将整个 Hash 表划分为多个分段； 而每个 Segment 元素，即每个分段则类似于一个Hashtable；这样，在执行 put 操作时首先根据 hash 算法定位到元素属于哪个 Segment，然后对该Segment 加锁即可。因此，ConcurrentHashMap 在多线程并发编程中可是实现多线程 put 操作，不过其最大并发度受 Segment 的个数限制。
>
> JDK1.8： 底层采用数组+链表+红黑树的方式实现，而加锁则采用 CAS 和 synchronized 实现
>
> 参考文章：https://blog.csdn.net/weixin_44460333/article/details/86770169

## CourrentHashMap JDK1.7和JDK1.8有什么区别？

> 1. Java 7为实现并行访问，引入了Segment这⼀结构，实现了分段锁，理论上最大并发度与Segment个数相等。
>
> 2. Java 8为进⼀步提高并发性，摒弃了分段锁的方案，而是直接使⽤一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过⼀定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示
>
>    ![image-20210317143037624](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317143037624.png)



## 为什么 ConcurrentHashMap 底层为什么要红黑树

> 因为发生 hash 冲突的时候，会在链表上新增节点，但是链表过长的话会影响检索效率，引入红黑树可以提高插入和查询的效率。

## 谈谈 Currenthashmap 的扩容机制

> JDK1.7：
>
> 先对数组的长度增加一倍，然后遍历原来的旧的 table 数组，把每一个数组元素也就是 Node 链表迁移到新的数组里面，最后迁移完毕之后，把新数组的引用直接替换旧的。
>
> JDK1.8：
>
> 扩容时候会判断这个值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数 i，然后利用 tabAt 方法获得 i 位置的元素 f，初始化一个 forwardNode 实例 fwd，如果 f == null，则在 table 中的 i 位置放入 fwd，否则采用头插法的方式把当前旧 table 数组的指定任务范围的数据给迁移到新的数组中，然后给旧 table 原位置赋值 fwd。直到遍历过所有的节点以后就完成了复制工作，把 table 指向 nextTable，并更新 sizeCtl 为新数组大小的 0.75 倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断 head 节点是否为forwardNode 节点，如果是就帮助扩容。
>
> 参考文章：https://blog.csdn.net/axibaaa/article/details/97109455

## jdk1.8中ConcurrentHashMap size大于8时会转化成红黑树，请问有什么作用，如果通过remove操作，size小于8了，会发生什么？

## ConcurrentHashMap 的并发度是什么？

> ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable能同时有两条线程获取 Hashtable 中的数据吗？

## java arraylist,linkedlist区分及实现原理，hashmap和concurrenthashmap区分及实现原理，concurrenthashmap 1.7和1.8区分，实现细节，linkedhashmap排序原理，应用如何保证数据幂等

> 1. java arraylist,linkedlist区分及实现原理：
>
>    ![image-20210317141647304](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317141647304.png)
>
>    1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
>     2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
>     3. 对于添加和删除操作add和remove，⼀般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。
>
> 2. concurrenthashmap 1.7和1.8区分：
>    
>       去除 Segment + HashEntry + Unsafe的实现，改为 Synchronized + CAS + Node + Unsafe的实现。其实 Node 和 HashEntry 的内容⼀样，但是HashEntry是⼀个内部类。用 Synchronized + CAS 代替 Segment ，这样锁的粒度更小了，并且不是每次都要加锁了，CAS尝试失败了再加锁。
>       put()方法中初始化数组大小时，1.8不用加锁，因为用了个 sizeCtl变量，将这个变量置为-1，就表明table正在初始化。
>       
> 3. linkedhashmap排序原理：
>
>       ```java
>       public LinkedHashMap() { 
>           // 调⽤HashMap的构造⽅法，其实就是初始化Entry[] table
>           super();
>           // 这⾥是指是否基于访问排序，默认为false
>           accessOrder = false;
>       }
>       ```
>
>       1、LinkedHashMap存储数据是有序的，而且分为两种：插⼊顺序和访问顺序。默认为插⼊顺序。
>       2、LinkedHashMap有自己的静态内部类Entry，它继承了HashMap.Entry，定义如下:
>
>       ```java
>       /**
>        * LinkedHashMap entry. 
>        */
>       private static class Entry<K,V> extends HashMap.Entry<K,V> {
>           // These fields comprise the doubly linked list used for iteration.
>           Entry<K,V> before, after;
>           Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {
>               super(hash, key, value, next);
>           }
>       }
>       ```
>
> 	3、所以LinkedHashMap构造函数，主要就是调用HashMap构造函数初始化了一个Entry[] table，然后调用自身的init初始化了一个只有头结点的双向链表。

## HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？

> HashMap结构图
>
> ![image-20210315111205384](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210315111205384.png)
>
> 在 JDK1.7 及之前的版本中， HashMap 又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。
> JDK1.8 中，当同一个hash值（ Table 上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树。这就是 JDK7 与 JDK8 中 HashMap 实现的最大区别。
>
> 其下基于 JDK1.7.0_80 与 JDK1.8.0_66 做的分析
>
> **JDK1.7中**
> 使用一个 Entry 数组来存储数据，用key的 hashcode 取模来决定key会被放到数组里的位置，如果 hashcode 相同，或者 hashcode 取模后的结果相同（ hash collision ），那么这些 key 会被定位到 Entry 数组的同一个格子里，这些 key 会形成一个链表。
> 在 hashcode 特别差的情况下，比方说所有key的 hashcode 都相同，这个链表可能会很长，那么 put/get 操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到 O(n)
>
> **JDK1.8中**
> 使用一个 Node 数组来存储数据，但这个 Node 可能是链表结构，也可能是红黑树结构
>
> * 如果插入的 key 的 hashcode 相同，那么这些key也会被定位到 Node 数组的同一个格子里。
>
> * 如果同一个格子里的key不超过8个，使用链表结构存储。
>
> * 如果超过了8个，那么会调用 treeifyBin 函数，将链表转换为红黑树。
>
> 那么即使 hashcode 完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销
> 也就是说put/get的操作的时间复杂度最差只有 O(log n)
> 听起来挺不错，但是真正想要利用 JDK1.8 的好处，有一个限制：
> key的对象，必须正确的实现了 Compare 接口
> 如果没有实现 Compare 接口，或者实现得不正确（比方说所有 Compare 方法都返回0），那 JDK1.8 的 HashMap 其实还是慢于 JDK1.7 的
>
> **简单的测试数据如下**
> 向 HashMap 中 put/get 1w 条 hashcode 相同的对象
>
> JDK1.7: put 0.26s ， get 0.55s 
>
> JDK1.8 （未实现 Compare 接口）： put 0.92s ， get 2.1s
>
> 但是如果正确的实现了 Compare 接口，那么 JDK1.8 中的 HashMap 的性能有巨大提升，这次 put/get 100W条 hashcode 相同的对象
>
> JDK1.8 （正确实现 Compare 接口，）： put/get 大概开销都在320 ms 左右

## LinkedHashMap 的应用

> 基于 LinkedHashMap 的访问顺序的特点，可构造一个 LRU（Least Recently Used） 最近最少使用简单缓存。也有一些开源的缓存产品如 ehcache 的淘汰策略（ LRU ）就是在 LinkedHashMap 上扩展的。

## 数组在内存中如何分配

> 对于 Java 数组的初始化，有以下两种方式，这也是面试中经常考到的经典题目：
> 静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度，如：
>
> ```java
> //只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为4 
> String[] computers = {"Dell", "Lenovo", "Apple", "Acer"}; //① 
> //只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为3 
> String[] names = new String[]{"多啦A梦", "大雄", "静香"}; //②
> ```
>
> 动态初始化：初始化时由程序员显示的指定数组的长度，由系统为数据每个元素分配初始值，如：
>
> ```java
> //只是指定了数组的长度，并没有显示的为数组指定初始值，但是系统会默认给数组数组元素分配初始值为null
> String[] cars = new String[4]; //③
> ```
>
> 因为 Java 数组变量是引用类型的变量，所以上述几行初始化语句执行后，三个数组在内存中的分配情况如下图所示：
>
> ![image-20210316044151271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316044151271.png)
>
> 由上图可知，静态初始化方式，程序员虽然没有指定数组长度，但是系统已经自动帮我们给分配了，而动态初始化方式，程序员虽然没有显示的指定初始化值，但是因为 Java 数组是引用类型的变量，所以系统也为每个元素分配了初始化值 null ，当然不同类型的初始化值也是不一样的，假设是基本类型int类型，那么为系统分配的初始化值也是对应的默认值0。

## Arrays.sort 和 Collections.sort实现原理和区别

> > 原文章地址：https://www.cnblogs.com/firecode7/p/13275895.html
>
> **Collection和Collections区别**
> java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
> java.util.Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、
> 线程安全等操作。 然后还有混排（Shuffling）、反转（Reverse）、替换所有的元素（fill）、拷贝（copy）、返回Collections中最小元素（min）、返回Collections中最大元素（max）、返回指定源列表中最后一次出现指定目标列表的起始位置（ lastIndexOfSubList ）、返回指定源列表中第一次出现指定目标列表的起始位置（ IndexOfSubList ）、根据指定的距离循环移动指定列表中的元素（Rotate）;
>
> **事实上Collections.sort方法底层就是调用的Arrays.sort方法**
>
> Collections 中的sort() 方法如下：
>
> ```java
> public static <T extends Comparable<? super T>> void sort(List<T> list) {
>       list.sort(null);
> }
> ```
>
> 其中调用的list.sort() 为：
>
> ```java
> default void sort(Comparator<? super E> c) {
>     Object[] a = this.toArray();
>     Arrays.sort(a, (Comparator) c);
>     ListIterator<E> i = this.listIterator();
>     for (Object e : a) {
>         i.next();
>         i.set((E) e);
>     }
> }
> ```
>
> 其中调用的Arrays.sort() 为：
>
> ```java
> public static <T> void sort(T[] a, Comparator<? super T> c) { if (c == null) {
>     sort(a); } else {
>     if (LegacyMergeSort.userRequested)
>         legacyMergeSort(a, c);
>     else
>         TimSort.sort(a, 0, a.length, c, null, 0, 0); }
> }
> ```
>
> legacyMergeSort (a)：归并排序 
>
> TimSort.sort() ： Timsort 排序
>
> Timsort 排序是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法
>
> Timsort的核心过程
>
> > TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分
> > 区。排序的输入的单位不是一个个单独的数字，而是一个个的块分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的run 便是排好序的结果。
>
> 综上述过程，Timsort算法的过程包括
> （0）如何数组长度小于某个值，直接用二分插入排序算法
> （1）找到各个run，并入栈
> （2）按规则合并run

## Cloneable 接口实现原理

> Cloneable接口是Java开发中常用的一个接口， 它的作用是使一个类的实例能够将自身拷贝到另一个新的实例中，注意，这里所说的“拷贝”拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。
>
> 在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现Cloneable接口，并重写clone()方法，就可以通过调用clone()方法的方式简洁地实现实例拷贝功能.
>
> 深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然Java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。
>
> 浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象 A1 中包含对 B1 的引用， B1 中包含对 C1 的引用。浅拷贝 A1 得到 A2 ， A2 中依然包含对 B1 的引用， B1 中依然包含对 C1 的引用。深拷贝则是对浅拷贝的递归，深拷贝 A1 得到 A2 ， A2 中包含对 B2 （ B1 的 copy ）的引用， B2 中包含对 C2 （ C1 的 copy ）的引用。
> 若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝。

## 深拷贝和浅拷贝？

> 浅拷贝
>
> 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。 简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。
>
> 深拷贝
>
> 深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。

## final finally finalize

> final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表
> 示该变量是一个常量不能被重新赋值。
>
> finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块
> 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
>
> finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
> 用，当我们调用 System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的
> 最后判断。

## final，finally，finalize 的区别

> final：变量、类、方法的修饰符，被 final 修饰的类不能被继承，变量或方法被 final 修饰 则不能被修改和重写。
>
> finally：异常处理时提供 finally 块来执行清除操作，不管有没有异常抛出，此处代码都会被执行。如果 try 语句块中包含 return 语句，finally 语句块是在 return 之后运行；
>
> finalize：Object 类中定义的方法，若子类覆盖了 finalize()方法，在在垃圾收集器将对象从内存中清除前，会执行该方法，确定对象是否会被回收。

# 计算机基础

## 进程和线程的区别

> 进程：具有一定独立功能的程序，是系统进行资源分配和调度运行的基本单位。
>
> 线程：进程的一个实体，是 CPU 调度的基本单位，也是进程中执行运算的最小单位，即执行处理机调度的基本单位，如果把进程理解为逻辑上操作系统所完成的任务，线程则表示完成该任务的许多可能的子任务之一。
>
> 关系：一个进程可有多个线程，至少一个；一个线程只能属于一个进程。同一进程的所有线程共享该进程的所有资源。不同进程的线程间要利用消息通信方式实现同步。
>
> 区别：进程有独立的地址空间，而多个线程共享内存；进程具有一个独立功能的程序，线程不能独立运行，必须依存于应用程序中。

## 并行跟并发有什么区别？ 

> 并发：指应用交替执行不同的任务，多线程原理 
>
> 并行：指应用同时执行不用的任务 
>
> 区别：一个是交替执行，一个是同时执行。

## 介绍⼀下红黑树、⼆叉平衡树。

> 理解这篇：https://juejin.im/post/5a27c6946fb9a04509096248

## 红黑树原理？ 

> (1) 红黑树的性质：红黑树是一个二叉搜索树。在每个节点增加了一个存储位记录节点的颜色，可以是 RED，也可以是 BLACK，通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的两倍，加以平衡。性质如下： 
>
> i. 每个节点颜色不是黑色就是红色 
>
> ii. 根节点的颜色是黑色的 
>
> iii. 如果一个节点是红色，那么他的两个子节点就是黑色的， 没有持续的红节点 
>
> iv. 对于每个节点，从该节点到其后代叶节点的简单路径上， 均包含相同数目的黑色节点。

## 二叉搜索树和平衡二叉树有什么关系，强平衡二叉树（AVL 树）和弱平衡二叉树 （红黑树）有什么区别?

> **二叉搜索树**
>
> 也称二叉查找树，或二叉排序树。定义也比较简单，要么是一颗空 树，要么就是具有如下性质的二叉树： 
>
> （1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 
>
> （2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的 值；
>
> （3）任意节点的左、右子树也分别为二叉查找树； 
>
> （4）没有键值相等的节点。 
>
> **平衡二叉树**
>
> 在二叉搜索树的基础上多了两个重要的特点 
>
> （1）左右两子树的高度差的绝对值不能超过 1； 
>
> （2）左右两子树也是一颗平衡二叉树。
>
> **红黑树**
>
> 红黑树是在普通二叉树上，对每个节点添加一个颜色属性形成的，需要同时满足一下五条性质 
>
> （1）节点是红色或者是黑色；
>
> （2）根节点是黑色；
>
> （3）每个叶节点（NIL 或空节点）是黑色；
>
> （4）每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；
>
> （5）从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点。
>
> 区别：AVL 树需要保持平衡，但它的旋转太耗时，而红黑树就是一个没有 AVL 树那样平衡，因此插入、删除效率会高于 AVL 树，而 AVL 树的查找效率显然高于红黑树。
>
> 参考文章 1：https://blog.csdn.net/qq_25940921/article/details/82183093 
>
> 参考文章 2：https://blog.csdn.net/yang_yulei/article/details/26066409

## B 树和 B+树的区别，为什么 MySQL 要使用 B+树？

> B 树：
>
> （1）关键字集合分布在整颗树中；
>
> （2）任何一个关键字出现且只出现在一个结点中；
>
> （3）搜索有可能在非叶子结点结束；
>
> （4）其搜索性能等价于在关键字全集内做一次二分查找；
>
> B+树：
>
> （1）有 n 棵子树的非叶子结点中含有 n 个关键字（b 树是 n-1 个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b 树是每个关键字都保存数据）；
>
> （2）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；
>
> （3）所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字；
>
> （4）通常在 b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点；
>
> （5）同一个数字会在不同节点中重复出现，根节点的最大元素就是 b+树的最大元素。
>
> B+树相比于 B 树的查询优势：
>
> （1）B+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
>
> （2）B+树查询必须查找到叶子节点，B 树只要匹配到即可不用管元素位置，因此 B+ 树查找更稳定（并不慢）；
>
> （3）对于范围查找来说，B+树只需遍历叶子节点链表即可，B 树却需要重复地中序遍历
>
> 参考文章：https://www.cnblogs.com/xueqiuqiu/articles/8779029.html

## 讲一下常见编码方式？ 

> 编码的意义：计算机中存储的最小单元是一个字节即 8bit，所能表示的字符范围是 255 个， 而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻译成计算机能懂的语言。 
>
> 1）ASCII 码：总共 128 个，用一个字节的低 7 位表示，0〜31 控制字符如换回车删除等；32~126 是打印字符，可通过键盘输入并显示出来； 
>
> 2）ISO-8859-1,用来扩展 ASCII 编码，256 个字符，涵盖了大多数西欧语言字符。 
>
> 3）GB2312:双字节编码，总编码范围是 A1-A7,A1-A9 是符号区，包含 682 个字符，B0-B7 是 汉字区，包含 6763 个汉字； 
>
> 4）GBK 为了扩展 GB2312,加入了更多的汉字，编码范围是 8140~FEFE，有 23940 个码位，能表示 21003 个汉字。 
>
> 5）UTF-16: ISO 试图想创建一个全新的超语言字典，世界上所有语言都可通过这本字典 Unicode 来相互翻译，而 UTF-16 定义了 Unicode 字符在计算机中存取方法，用两个字节来表 示 Unicode 转化格式。不论什么字符都可用两字节表示，即 16bit，固叫 UTF-16。 
>
> 6）UTF-8：UTF-16 统一采用两字节表示一个字符，但有些字符只用一个字节就可表示，浪费存储空间，而 UTF-8 采用一种变长技术，每个编码区域有不同的字码长度。 不同类型的字符可以由1~6个字节组成。

## utf-8 编码中的中文占几个字节；int 型几个字节？ 

> utf-8 是一种变长编码技术，utf-8 编码中的中文占用的字节不确定，可能 2 个、3 个、4 个,int 型占 4 个字节。

## int、char、long 各占多少字节数？

> int\float 占用 4 个字节，short\char 占用 2 个字节，long 占用 8 个字节，byte/boolean 占用 1 个字节
>
> 基本数据类型存放在栈里，包装类栈里存放的是对象的引用，即值的地址，而值存放在堆里。

## epoll 和 poll 的区别，及其应用场景

> select 和 epoll 都是 I/O 多路复用的方式，但是 select 是通过不断轮询监听 socket 实 现，epoll 是当 socket 有变化时通过回掉的方式主动告知用户进程实现 
>
> 参考文章:https://www.cnblogs.com/hsmwlyl/p/10652503.html

# Java机制:注解/反射/解析/分派/三大特性等

## 有没有写过或者看过custom classloader？

> 了解⼀下即可：https://www.jianshu.com/p/3036b46f1188

## 说说你对 Java 注解的理解

> 注解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@
>
> ```java
> public @interface TestAnnotation { }
> ```
>
> 使用时@TestAnnotation 来引用，要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解。元标签有@Retention @Documented @Target @Inherited @Repeatable 五种 
>
> **@Retention** 
>
> 说明注解的存活时间，取值有 RetentionPolicy.SOURCE。注解只在源码阶段保留，在编译器进行编译时被丢弃；RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到 JVM 中。RetentionPolicy.RUNTIME 可以留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。
>
> **@Documented** 
>
> 注解中的元素包含到 javadoc中去
>
> **@Target** 
>
> 限定注解的应用场景：
>
> ElementType.FIELD给属性进行注解；
>
> ElementType.LOCAL_VARIABLE可以给局部变量进行注解；
>
> ElementType.METHOD可以给方法进行注解；
>
> ElementType.PACKAGE 可以给一个包进行注解；
>
> ElementType.TYPE 可以给一个类型进行注解，如类、接口、枚举。
>
> **@Inherited**
>
> 若一个超类被@Inherited 注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解；
>
> 注解的作用： 
>
> 1）提供信息给编译器：编译器可利用注解来探测错误和警告信息 
>
> 2）编译阶段：软件工具可以利用注解信息来生成代码、html 文档或做其它相应处理； 
>
> 3）运行阶段：程序运行时可利用注解提取代码
>
> 注解是通过反射获取的，可以通过 Class 对象的 **isAnnotationPresent()**方法判断它是否应用了某个注解，再通过 **getAnnotation()**方法获取 Annotation 对象。

## 说说你对 Java 反射的理解

> 在运行状态中，对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性。这种能动态获取信息及动态调用对象方法的功能称为 java 语言的反射机制。
>
> 反射的作用：开发过程中，经常会遇到某个类的某个成员变量、方法或属性是私有的，或只对系统应用开放，这里就可以利用 java 的反射机制通过反射来获取所需的私有成员或是方法。
>
> 1) 获取类的 Class 对象实例 
>
> ``` java
> Class clz = Class.forName("com.zhenai.api.Apple"); 
> ```
>
> 2) 根 据 Class 对 象 实 例 获 取 Constructor 对 象 
>
> ```java
> Constructor appConstructor = clz.getConstructor(); 
> ```
>
> 3) 使 用 Constructor 对 象 的 newInstance 方法获取反射类对象
>
> ```java
> Object appleObj = appConstructor.newInstance(); 
> ```
>
> 4) 获取方法的 Method 对象 
>
> ``` java
> Method setPriceMethod = clz.getMethod("setPrice", int.class);
> ```
>
> 5) 利用 invoke 方法调用方法
>
> ```java
> setPriceMethod.invoke(appleObj, 14); 
> ```
>
> 6) 通过 getFields()可以获取 Class 类的属性，但无法获取私有属性，而getDeclaredFields()可以获取到包括私有属性在内的所有属性。带有 Declared 修饰的方法可以反射到私有的方法，没有 Declared 修饰的只能用来反射公有的方法，其他如 Annotation\Field\Constructor 也是如此。

## Java反射机制

> Java 反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为Java 的反射机制。
> Class 类与 java.lang.reflect 类库一起对反射的概念进行了支持，该类库包含了 Field,Method,Constructor 类(每个类都实现了 Member 接口)。这些类型的对象时由 JVM 在运行时创建的，用以表示未知类里对应的成员。
> 这样你就可以使用 Constructor 创建新的对象，用 get() 和 set() 方法读取和修改与 Field 对象关联的字段，用
> invoke() 方法调用与 Method 对象关联的方法。另外，还可以调用 getFields() getMethods() 和getConstructors() 等很便利的方法，以返回表示字段，方法，以及构造器的对象的数组。这样匿名对象的信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。
>
> ```java
> import java.lang.reflect.Constructor; 
> public class ReflectTest { 
>     public static void main(String[] args) throws Exception { 
>         Class clazz = null; 
>         clazz = Class.forName("com.jas.reflect.Fruit"); 
>         Constructor<Fruit> constructor1 = clazz.getConstructor();
>         Constructor<Fruit> constructor2 = clazz.getConstructor(String.class);
>         Fruit fruit1 = constructor1.newInstance(); 
>         Fruit fruit2 = constructor2.newInstance("Apple"); 
>     } 
> }
> class Fruit{ 
>     public Fruit(){ 
>         System.out.println("无参构造器 Run..........."); 
>     }
>     public Fruit(String type){ 
>         System.out.println("有参构造器 Run..........." + type); 
>     } 
> }
> ```
>
> 运行结果： 无参构造器 Run……….. 有参构造器 Run………..Apple

## Java获取反射的三种方法

> 1.通过new对象实现反射机制 
>
> 2.通过路径实现反射机制 
>
> 3.通过类名实现反射机制
>
> ```java
> public class Student { 
>     private int id; 
>     String name; 
>     protected boolean sex; 
>     public float score; 
> }
> ```
>
> ```java
> public class Get { 
>     //获取反射机制三种方式 
>     public static void main(String[] args) throws ClassNotFoundException { 
>         //方式一(通过建立对象) 
>         Student stu = new Student(); 
>         Class classobj1 = stu.getClass(); 
>         System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径） 
>         Class classobj2 = Class.forName("fanshe.Student");
>         System.out.println(classobj2.getName()); //方式三（通过类名） 
>         Class classobj3 = Student.class; 
>         System.out.println(classobj3.getName()); 
>     } 
> }
> ```

## 说一下泛型原理，并举例说明

> 泛型就是将类型变成参数传入，使得可以使用的类型多样化，从而实现解耦。Java 泛型是在 Java1.5 以后出现的，为保持对以前版本的兼容，使用了擦除的方法实现泛型。擦除是指在一定程度无视类型参数 T，直接从 T 所在的类开始向上 T 的父类去擦除，如调用泛型方法， 传入类型参数 T 进入方法内部，若没在声明时做类似 public T methodName(T extends Father t){}，Java 就进行了向上类型的擦除，直接把参数 T 当做 Object 类来处理，而不是传进去的 T。 即在有泛型的任何类和方法内部，它都无法知道自己的泛型参数，擦除和转型都是在边界上发生，即传进去的参在进入类或方法时被擦除掉，但传出来的时候又被转成了我们设置的 T。 在泛型类或方法内，任何涉及到具体类型（即擦除后的类型的子类）操作都不能进行，如 new T()，或者 T.play()（play 为某子类的方法而不是擦除后的类的方法）

## 谈谈你对解析与分派的认识

> 解析指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。
>
> 分派可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。动态分派则需要根据实际类型来调用相应的方法。

## 修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法?
> 会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和==都是比较栈内局部变量表中指向堆内存地址值是否相等。

> PS:
>
> JAVA中什么是方法签名？
>
> 官方的说明： https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html
>
> 方法声明的两个组件构成了方法签名 : 方法的名称和参数类型。
>
> 举例：
>
> 这里是一个典型的方法声明
>
> ``` java
> public double calculateAnswer(double wingSpan, int numberOfEngines,
>                            double length, double grossTons) {
>  //do the calculation here
> }
> ```
>
> 上面方法的签名是
>
> ```java
> calculateAnswer(double, int, double, double)
> ```
>
> ————————————————
> 版权声明：本文为CSDN博主「雪花无道」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/u010592926/article/details/76637936/

## 谈谈对 java 多态的理解

> 同一个消息可以根据发送对象的不同而采用多种不同的行为方式，在执行期间判断所引用的对象的实际类型，根据其实际的类型调用其相应的方法。
>
> 作用：消除类型之间的耦合关系。
>
> 实现多态的必要条件：继承、重写（因为必须调用父类中存在的方法）、父类引用指向子类对象。

## Java 中实现多态的机制是什么？

> 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。这样就可以不用修改源程序，就可以让引用变量绑定到各种不同的类实现上。
>
> Java 实现多态有三个必要条件：继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。

## 抽象类和接口区别？

> 抽象类在类前面须用 abstract 关键字修饰，一般至少包含一个抽象方法，抽象方法指只有声明，用关键字abstract 修饰，没有具体的实现的方法。因抽象类中含有无具体实现的方法，固不能用抽象类创建对象。当然如果只是用 abstract 修饰类而无具体实现，也是抽象类。抽象类也可以有成员变量和普通的成员方法。抽象方法必须为 public 或 protected（若 为 private，不能被子类继承，子类无法实现该方法）。若一个类继承一个抽象类，则必须实现父类中所有的抽象方法，若子类没有实现父类的抽象方法，则也应该定义为抽象类。
>
> 接口用关键字 interface 修饰，接口也可以含有变量和方法，接口中的变量会被隐式指定为 public static final 变量。方法会被隐式的指定为 public abstract，接口中的所有方法均不 能有具体的实现，即接口中的方法都必须为抽象方法。若一个非抽象类实现某个接口，必须实现该接口中所有的方法。
>
> 区别：
>
> 1）抽象类可以提供成员方法实现的细节，而接口只能存在抽象方法；
>
> 2）抽象类的成员变量可以是各种类型，而接口中成员变量只能是 public static final 类型；
>
> 3）接口中不能含有静态方法及静态代码块，而抽象类可以有静态方法和静态代码块；
>
> 4）一个类只能继承一个抽象类，用 extends 来继承，却可以实现多个接口，用 implements 来实现接口。

## 抽象类的意义

> 抽象类是用来提供子类的通用性，用来创建继承层级里子类的模板，减少代码编写，有利于代码规范化。

## 抽象类与接口的应用场景?

> 抽象类的应用场景：
>
> 1）规范了一组公共的方法，与状态无关，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定状态来实现特定功能；
>
> 2）定义一组接口，但不强迫每个实现类都必须实现所有的方法，可用抽象类定义一组方法体,可以是空方法体，由子类选择自己感兴趣的方法来覆盖；

## 抽象类是否可以没有方法和属性？

> 可以

## 接口的意义

> 1）有利于代码的规范，对于大型项目，对一些接口进行定义，可以给开发人员一个清晰的指示，防止开发人员随意命名和代码混乱，影响开发效率。
>
> 2）有利于代码维护和扩展，当前类不能满足要求时，不需要重新设计类，只需要重新写个类实现对应的方法。
>
> 3）解耦作用，全局变量的定义，当发生需求变化时，只需改变接口中的值即可。
>
> 4）直接看接口，就可以清楚知道具体实现类间的关系，代码交给别人看，别人也能立马明白。

## 泛型中 extends 和 super 的区别

> <? extends T>限定参数类型的上界，参数类型必须是 T 或 T 的子类型，但对于 List<? extends T>，不能通过 add()来加入元素，因为不知道<? extends T>是 T 的哪一种子类；
>
> <? super T>限定参数类型的下界，参数类型必须是 T 或 T 的父类型，不能能过 get()获取 元素，因为不知道哪个超类；

## 父类的静态方法能否被子类重写？静态属性和静态方法是否可以被继承？

> > 文章链接：https://www.jianshu.com/p/15e21428d884
>
> 父类的静态方法和属性不能被子类重写，即使子类中的静态方法与父类中的静态方法完全一样，也是两个完全不同的方法。但子类可以继承父类静态方法和属性，如父类和子 类都有同名同参同返回值的静态方法 show()，声明的实例 Father father = new Son(); (Son extends Father)，会调用 father 对象的静态方法。静态是指在编译时就会分配内存且一直存在，跟对象实例无关。
>
> ```java
> class Fruit{
> 
>     static String color = "五颜六色";
>     static public void call() {
>         System.out.println("这是一个水果");
>     }
> }
> public class Banana extends Fruit{
> 
>     static String color = "黄色";
>     static public void call() {
>         System.out.println("这是一个香蕉");
>     }
> 
>     public static void main(String[] args) {
> 
>         Fruit fruit = new Banana();
>         System.out.println(fruit.color);    //五颜六色
>         fruit.call();         //这是一个水果
>     }
> }
> ```
>
> 如代码所示，如果能够被重写，则输出的应该是这是一个香蕉。与此类似的是，静态变量也不能够被重写。如果想要调用父类的静态方法，应该使用类来调用。那为什么会出现这种情况呢？
> 我们要从重写的定义来说：
>
> > 重写指的是根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型。
>
> 对于静态方法和静态变量来说，虽然在上述代码中使用对象来进行调用，但是底层上还是使用父类来调用的，静态变量和静态方法在编译的时候就将其与类绑定在一起。既然它们在编译的时候就决定了调用的方法、变量，那就和重写没有关系了。

## 序列化 Serializable 和 Parcelable 的区别

> **序列化**：将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输；
>
> **为什么要进行序列化**：开发过程中，我们需要将对象的引用传给其他 activity 或 fragment 使用时，需要将这些对象放到一个 Intent 或 Bundle 中，再进行传递，而 Intent 或 Bundle 只能识别基本数据类型和被序列化的类型。
>
> **Serializable**：表示将一个对象转换成可存储或可传输的状态。
>
> **Parcelable**：与 Serializable 实现的效果相同，也是将一个对象转换成可传输的状态，但它的实现原理是将一个完整的对象进行分解，分解后的每一部分都是 Intent 所支持的数据类型，这样实现传递对象的功能。 
>
> **Parcelable 实现序列化的重要方法**：序列化功能是由 writeToParcel 完成，通过 Parcel 中 的 write 方法来完成；反序列化由 CREATOR 完成，内部标明了如何创建序列化对象及数级， 通过 Parcel 的 read 方法完成；内容描述功能由 describeContents 方法完成，一般直接返回 0。
>
> **区别**：Serializable 在序列化时会产生大量临时变量，引起频繁 GC。Serializable 本质上使用了反射，序列化过程慢。Parcelable 不能将数据存储在磁盘上，在外界变化时，它不能很好的保证数据的持续性。
>
> **选择原则**：若仅在内存中使用，如 activity\service 间传递对象，优先使用 Parcelable，它性能高。若是持久化操作，优先使用 Serializable
>
> **注意**：静态成员变量属于类，不属于对象，固不会参与序列化的过程；用 transient 关键字编辑的成员变量不会参与序列化过程；可以通过重写 writeObject()和 readObject()方法来 重写系统默认的序列化和反序列化。

## 如何将一个 Java 对象序列化到文件里？ 

> ObjectOutputStream.writeObject()负责将指定的流写入，ObjectInputStream.readObject()从指 定流读取序列化数据。 
>
> //写入 
>
> ```java
> try { 
>     	ObjectOutputStream os = new ObjectOutputStream(new 			FileOutputStream("D:/student.txt"));
>     	os.writeObject(studentList);
>     	os.close();
> } catch(FileNotFoundException e) { 
>     	e.printStackTrace(); 
> } catch(IOException e) { 
>     	e.printStackTrace();
> }
> ```

## 什么是内部类？内部类的作用

> 内部类指在类的内部再定义另一个类。
>
> 内部类的作用：
>
> 1）实现多重继承，因为 java 中类的继承只能单继承，使用内部类可达到多重继承；
>
> 2）内部类可以很好的实现隐藏，一般非内部类，不允许有 private 或 protected 权限的，但内部类可以；
>
> 3）减少了类文件编译后产生的字节码文件大小；内部类在编译完后也会产生.class 文件，但文件名称是：外部类名称$内部类名称.class。
>
> 内部类分为以下几种：
>
> 1）成员内部类，作为外部类的一个成员存在，与外部类的属性、方法并列，成员内部类持有外部类的引用，成员内部类不能定义 static 变量和方法。应用场合：每一个外部类都需要一个内部类实例，内部类离不开外部类存在。 
>
> 2）静态内部类，内部类以 static 声明，其他类可通过外部类.内部类来访问。
>
> 特点：不会持有外部类的引用，可以访问外部类的静态变量，若要访问成员变量须通过外部类的实例访问。 应用场合：内部类不需要外部类的实例，仅为外部类提供或逻辑上属于外部类，逻辑上可单独存在。
>
> 设计的意义：加强了类的封装性（静态内部类是外部类的子行为或子属性，两者保持着一定关系），提高了代码的可读性（相关联的代码放在一起）。
>
> 3）匿名内部类，在整个操作中只使用一次，没有名字，使用 new 创建，没有具体位置。
>
> 4）局部内部类，在方法内或是代码块中定义类。

## Java中Native关键字的作用

> > https://www.cnblogs.com/KingIceMou/p/7239668.html

# 异常

## Java 的异常体系 

> Java 中Throwable是所有异常和错误的超类，两个直接子类是 Error（错误）和 Exception（异 常）：
>
> 1）Error 是程序无法处理的错误，由 JVM 产生和抛出，如 OOM、ThreadDeath 等。这些异常 发生时，JVM 一般会选择终止程序。 
>
> 2）Exception 是程序本身可以处理的异常，又分为运行时异常(RuntimeException)(也叫 Checked Eception)和非运行时异常(不检查异常Unchecked Exception)。运行时异常有 NullPointerException\IndexOutOfBoundsException等，这些异常一般是由程序逻辑错误引起的，应尽可能避免。非运行时异常有 IOException\SQLException\FileNotFoundException 以及由用户自定义的 Exception 异常等。

## 异常分类以及处理机制

> ![image-20210316035532779](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316035532779.png)
>
> Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。
> Throwable又派生出Error类和Exception类。
> 错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。
> 因此，程序员应该关注Exception为父类的分支下的各种异常类。
> 异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。
>
> ![image-20210316035702022](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316035702022.png)
>
> 总体上我们根据 Javac 对异常的处理要求，将异常类分为二类。
>
> **非检查异常（ unckecked exception ）**
>
> Error 和 RuntimeException 以及他们的子类。 javac 在编译时，
> 不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用 try… catch…finally ）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误 ArithmeticException ，错误的强制类型转换错误 ClassCastException ，数组索引越界 ArrayIndexOutOfBoundsException ，使用了空对象
> NullPointerException 等等。
>
> **检查异常（ checked exception ）**
>
> 除了 Error 和 RuntimeException 的其它异常。 javac 强制要求程序员为这样的异常做预备处理工作（使用 try…catch…finally 或者 throws ）。在方法中要么用 try-catch 语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如 SQLException , IOException , ClassNotFoundException 等。
>
> 需要明确的是：检查和非检查是对于 javac 来说的，这样就很好理解和区分了。

# 网络协议

## TCP的三次握⼿四次挥⼿机制？

> 1. TCP建⽴连接的过程。
>
>    三次握⼿：
>    1. 第⼀次握⼿(客户端发送syn包到服务器端)：客户端发送syn包到服务器端，进⼊syn_send状态，等待服务器端的确认；
>    2. 第⼆次握⼿(服务器返回syn+ack包给客户端)：服务器端收到客户端的syn包，发送syn+ack包给客户端，进⼊syn_recv状态；
>    3. 第三次握⼿(客服端返回ack包给服务端)：客户端收到服务器端的syn+ack包，发送个ack包到服务器端，⾄此，客户端与服务器端进⼊established状态；
>    4. 握⼿过程中传送的包不包含任何数据，连接建⽴后才会开始传送数据，理想状态下，TCP连接⼀旦建⽴，在通信双⽅的任何⼀⽅主动关闭连接前，TCP连接都会⼀直保持下去。
>
> 2. TCP断开连接的过程。
>    四次挥⼿：
>
>    1. 第⼀次挥⼿：主动关闭⽅发送fin包到被动关闭⽅，告诉被动关闭⽅我不会再给你发送数据了；
>    2. 第⼆次挥⼿：被动关闭⽅收到syn包，发送ack给对⽅，确认序号为收到序号+1；
>    3. 第三次挥⼿：被动关闭⽅也也发送fin包给主动关闭⽅，告诉对⽅我也不会给你发送数据了；
>    4. 第四次挥⼿：主动关闭⽅收到syn包，发送ack给对⽅，⾄此，完成四次挥⼿；

## HTTP 有哪些问题，加密算法有哪些，针对不同加密方式可能产生的问题，及其 HTTPS 是如何保证安全传输

> HTTP 的不足：
>
> 通信使用明文，内容可能会被窃听；
>
> 不验证通信方的身份，因此有可能遭遇伪装；
>
> 无法证明报文的完整性，有可能已遭篡改；
>
> 常用加密算法：MD5 算法、DES 算法、AES 算法、RSA 算法 
>
> 参考文章：https://blog.csdn.net/baidu_22254181/article/details/82594072

## Https原理？

> HTTPS协议就是基于SSL的HTTP协议
> HTTPS使⽤与HTTP不同的端⼝（HTTPM80 ， HTTPSM443）
> 提供了身份验证与加密通信⽅法，被⼴泛⽤于互联⽹上安全敏感的通
> 信。
>
> ![image-20210317132341641](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210317132341641.png)
>
> 
>
> 1、客户端请求SSL连接，并将⾃⼰⽀持的加密规则发给⽹站。
>
> 2、服务器端将⾃⼰的身份信息以证书形式发回给客户端。证书⾥⾯包含了⽹站地址，加密公钥，以及证书的颁发机构。
>
> 3、获得证书后，客户要做以下⼯作
> 验证证书合法性
> 如果证书受信任，客户端会⽣成⼀串随机数的密码，并⽤证书提供的公钥进⾏加密。
> 将加密好的随机数发给服务器。
>
> 4、获得到客户端发的加密了的随机数之后，服务器⽤⾃⼰的私钥进⾏解密，得到这个随机数，把这个随机数作为对称加密的密钥。（利⽤⾮对称加密传输对称加密的密钥）
>
> 5、之后服务器与客户之间就可以⽤随机数对各⾃的信息进⾏加密，解密。
> 注意的是：证书是⼀个公钥，这个公钥是进⾏加密⽤的。⽽私钥是进⾏解密⽤的。公钥任何都知道，私钥只有⾃⼰知道。这是⾮对称加密。
> ⽽对称加密就是钥匙只有⼀把，我们都知道。之所以⽤到对称加密，是因为对称加密的速度更快。⽽⾮对称加密的可靠性更⾼。
>
> 客户端请求--服务端发送证书（公钥）--客户端验证证书，并⽣成随机数，通过公钥加密后发送给服务端--服务端⽤私钥解密出随机数--对称加密传输数据。

## HTTP 和 https 区别？

> HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。 
>
> 使用 HTTPS 协议需要到CA（Certificate Authority，数字证书认证机构）申请证书，一般免费证书较少，因而需要一定费用。
>
> HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS 除了 TCP 的三个包，还要加 上 ssl 握手需要的 9 个包，所以一共是 12 个包。
>
> http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
>
> HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，HTTPS 比 HTTP 要更耗费服务器资源。 
>
> 参考文章：https://www.runoob.com/w3cnote/http-vs-https.html

## 谈谈你对 TCP / IP 协议的了解 

> TCP/IP 是一个协议簇，是一个开放的协议标准，所有人都可以免费使用，并且是 独立于硬件和操作系统的。
>
> TCP/IP 协议是不区分网络硬件的，它在局域网，广域网和互联网中都被广泛使用。
>
> TCP/IP 协议使用统一的网络地址分配的方案，网络中的每台电脑都具有唯一的 IP 地址。
>
> TCP/IP 协议是一个标准的高层协议，拥有极高的可靠性，可以为用户提供可靠的服务。
>
> 参考文章：https://blog.csdn.net/my_learning_road/article/details/79941273

## 什么是 TCP 粘包/拆包

> 1、要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
> 2、待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
> 3、要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出
> 去，将会发生粘包。
> 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

## TCP 粘包/拆包的解决办法

> 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在
> 接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
> 2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次
> 从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
> 3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将
> 不同的数据包拆分开。

## 静态代理和动态代理的区别，什么场景使用，如何实现？ 

> 代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。 
>
> 区别： 
>
> 1）静态代理：由程序员创建或是由特定工具生成，在代码编译时就确定了被代理的类是哪一个是静态代理。静态代理通常只代理一个类； 
>
> 2）动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类；
>
> 实现步骤：
>
> a.实现 InvocationHandler 接口创建自己的调用处理器；
>
> b.给 Proxy 类提供 ClassLoader 和代理接口类型数组创建动态代理类；
>
> c.利用反射机制得到动态代理类的构造函数；
>
> d.利用动态代理类的构造函数创建动态代理类对象； 
>
> 使用场景：
>
> Retrofit中直接调用接口的方法；
>
> Spring 的 AOP机制；

